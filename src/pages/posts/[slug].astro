---
import NotionBlocks from "@/components/NotionBlocks.astro";
import PostLayout from "@/layouts/BlogPost.astro";
import {
	extractTargetBlocks,
	resetCurrentHeadings,
	resetFirstImage,
	setCurrentHeadings,
	setTrackCurrentPageId,
} from "@/lib/blog-helpers";
import { getAllPosts, getPostContentByPostId, processFileBlocks } from "@/lib/notion/client";
import { getReferencesInPage } from "@/lib/blog-helpers";
import type { Post } from "@/lib/interfaces";
import { buildHeadings } from "@/utils";
import { BUILD_FOLDER_PATHS, LAST_BUILD_TIME, FOOTNOTES } from "@/constants";
import type { Block } from "@/lib/interfaces";
import fs from "fs/promises";
import path from "path";
import superjson from "superjson";

export async function getStaticPaths() {
	const posts = await getAllPosts();
	const allPostsMap: Record<string, Post> = Object.fromEntries(posts.map((p) => [p.PageId, p])); // Map of PageId to Post

	return posts.map((post) => {
		const referencesInPage = getReferencesInPage(post.PageId);
		const linkedPageIdsSet = new Set<string>(); // Use a Set to collect unique PageIds

		// Collect linked PageIds, automatically deduplicating
		if (referencesInPage) {
			referencesInPage.forEach((ref) => {
				if (ref.link_to_pageid) {
					linkedPageIdsSet.add(ref.link_to_pageid);
				}
				if (ref.other_pages) {
					ref.other_pages.forEach((richText) => {
						if (richText.InternalHref?.PageId) {
							linkedPageIdsSet.add(richText.InternalHref.PageId);
						} else if (richText.Mention?.Page?.PageId) {
							linkedPageIdsSet.add(richText.Mention.Page.PageId);
						}
					});
				}
			});
		}

		const linkedPageIds = Array.from(linkedPageIdsSet); // Convert Set back to an array

		// Check if the post was updated before LAST_BUILD_TIME
		const postLastUpdatedBeforeLastBuild =
			LAST_BUILD_TIME && post?.LastUpdatedTimeStamp && post.LastUpdatedTimeStamp < LAST_BUILD_TIME;

		// Check if any linked post was updated after LAST_BUILD_TIME
		const linkedPostsUpdated =
			!LAST_BUILD_TIME ||
			(linkedPageIds.length > 0 &&
				linkedPageIds.some((pageId) => {
					const linkedPost = allPostsMap[pageId];
					return linkedPost && linkedPost.LastUpdatedTimeStamp > LAST_BUILD_TIME;
				}));

		const shouldUseCache = postLastUpdatedBeforeLastBuild && !linkedPostsUpdated;

		return {
			params: { slug: post.Slug },
			props: { post, shouldUseCache, postLastUpdatedBeforeLastBuild },
		};
	});
}

interface Props {
	post: Post;
	shouldUseCache: boolean;
	postLastUpdatedBeforeLastBuild: boolean;
}

const { post, shouldUseCache, postLastUpdatedBeforeLastBuild } = Astro.props; // Extract shouldUseCache from props

resetCurrentHeadings();
let postFound = true;
let headings = null;
let blocks = null;
let referencesInPage = null;

if (!post) {
	console.log("Post not found. slug: ${slug}");
	postFound = false;
}

// Load cached HTML only if shouldUseCache is true
let cachedHtml = "";
if (postFound && shouldUseCache) {
	const cacheFilePath = path.join(BUILD_FOLDER_PATHS["blocksHtmlCache"], `${post.Slug}.html`);
	try {
		cachedHtml = await fs.readFile(cacheFilePath, "utf-8");
	} catch (e) {
		cachedHtml = ""; // Fallback to rendering if cache read fails
	}
}

let cachedHeadings = null;
const headingsCacheDir = BUILD_FOLDER_PATHS["headingsCache"];
if (postFound && postLastUpdatedBeforeLastBuild) {
	const headingsCacheFile = path.join(headingsCacheDir, `${post.Slug}.json`);
	try {
		const headingsData = await fs.readFile(headingsCacheFile, "utf-8");
		cachedHeadings = superjson.parse(headingsData);
	} catch (e) {
		cachedHeadings = null; // Fallback to building headings if cache read fails
	}
}

// Helper function to get children from a block
function getChildrenFromBlock(block: Block): Block[] | null {
	if (block.Paragraph?.Children) return block.Paragraph.Children;
	if (block.Heading1?.Children) return block.Heading1.Children;
	if (block.Heading2?.Children) return block.Heading2.Children;
	if (block.Heading3?.Children) return block.Heading3.Children;
	if (block.Quote?.Children) return block.Quote.Children;
	if (block.Callout?.Children) return block.Callout.Children;
	if (block.Toggle?.Children) return block.Toggle.Children;
	if (block.BulletedListItem?.Children) return block.BulletedListItem.Children;
	if (block.NumberedListItem?.Children) return block.NumberedListItem.Children;
	if (block.ToDo?.Children) return block.ToDo.Children;
	if (block.SyncedBlock?.Children) return block.SyncedBlock.Children;
	return null;
}

// Function to assign footnote indices recursively
function assignFootnoteIndices(blocks: Block[], footnoteNumber: { value: number }): void {
	blocks.forEach(block => {
		if (block.Footnotes && block.Footnotes.length > 0) {
			block.Footnotes.forEach(footnote => {
				footnote.Index = footnoteNumber.value++;
			});
		}

		// Recursively process children
		const children = getChildrenFromBlock(block);
		if (children && children.length > 0) {
			assignFootnoteIndices(children, footnoteNumber);
		}

		// Process column lists
		if (block.ColumnList?.Columns) {
			block.ColumnList.Columns.forEach(column => {
				if (column.Children) {
					assignFootnoteIndices(column.Children, footnoteNumber);
				}
			});
		}
	});
}

if (postFound) {
	const result = await getPostContentByPostId(post);
	blocks = result.blocks;
	referencesInPage = result.referencesInPage;

	// Assign footnote indices if generate-footnotes-section OR margin mode is enabled
	const generateSection = FOOTNOTES?.['in-page-footnotes-settings']?.['generate-footnotes-section'];
	const isMarginMode = FOOTNOTES?.['in-page-footnotes-settings']?.['intext-display']?.['small-popup-large-margin'];
	if ((generateSection || isMarginMode) && blocks) {
		const footnoteNumber = { value: 1 };
		assignFootnoteIndices(blocks, footnoteNumber);
	}

	// Use cached headings if available, otherwise build and save them
	if (cachedHeadings) {
		headings = cachedHeadings;
	} else {
		headings = buildHeadings(blocks);
		const headingsCacheFile = path.join(headingsCacheDir, `${post.Slug}.json`);
		try {
			await fs.writeFile(headingsCacheFile, superjson.stringify(headings), "utf-8");
		} catch (e) {
			console.error("Error saving headings cache:", e);
		}
	}
	setCurrentHeadings(headings);

	// Process file blocks only if cache isn't used
	const fileAtacchedBlocks = extractTargetBlocks(
		["image", "video", "file", "audio"],
		blocks,
	).filter((block) => {
		if (!block) return false;
		const imageOrVideoOrAudioOrFile = block.NImage || block.File || block.Video || block.NAudio;
		return (
			imageOrVideoOrAudioOrFile &&
			imageOrVideoOrAudioOrFile.File &&
			imageOrVideoOrAudioOrFile.File.Url
		);
	});

	await processFileBlocks(fileAtacchedBlocks);
}
---

{
	postFound && resetFirstImage() && setTrackCurrentPageId(post.PageId) && (
		<PostLayout post={post} headings={headings} shouldUseCache={shouldUseCache}>
			{shouldUseCache && cachedHtml ? (
				<div
					class="post-body max-w-[708px] print:max-w-full"
					data-html-type="cached"
					set:html={cachedHtml}
				/>
			) : (
				<div class="post-body max-w-[708px] print:max-w-full" data-html-type="new">
					<NotionBlocks blocks={blocks} />
				</div>
			)}
		</PostLayout>
	)
}
