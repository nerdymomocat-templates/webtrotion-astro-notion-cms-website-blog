---
import NotionBlocks from "@/components/NotionBlocks.astro";
import PostLayout from "@/layouts/BlogPost.astro";
import {
	extractTargetBlocks,
	resetCurrentHeadings,
	resetFirstImage,
	setCurrentHeadings,
	setTrackCurrentPageId,
	getReferencesInPage,
	loadCachedHtml,
	loadCachedHeadings,
	saveCachedHeadings,
} from "@/lib/blog-helpers";
import { getAllPosts, getPostContentByPostId, processFileBlocks } from "@/lib/notion/client";
import type { Post } from "@/lib/interfaces";
import { buildHeadings } from "@/utils";
import { LAST_BUILD_TIME } from "@/constants";
import { adjustedFootnotesConfig } from "@/lib/notion/client";
import type { Block } from "@/lib/interfaces";
import FootnotesSection from "@/components/blog/FootnotesSection.astro";

export async function getStaticPaths() {
	const posts = await getAllPosts();
	const allPostsMap: Record<string, Post> = Object.fromEntries(posts.map((p) => [p.PageId, p])); // Map of PageId to Post

	return posts.map((post) => {
		const referencesInPage = getReferencesInPage(post.PageId);
		const linkedPageIdsSet = new Set<string>(); // Use a Set to collect unique PageIds

		// Collect linked PageIds, automatically deduplicating
		if (referencesInPage) {
			referencesInPage.forEach((ref) => {
				if (ref.link_to_pageid) {
					linkedPageIdsSet.add(ref.link_to_pageid);
				}
				if (ref.other_pages) {
					ref.other_pages.forEach((richText) => {
						if (richText.InternalHref?.PageId) {
							linkedPageIdsSet.add(richText.InternalHref.PageId);
						} else if (richText.Mention?.Page?.PageId) {
							linkedPageIdsSet.add(richText.Mention.Page.PageId);
						}
					});
				}
			});
		}

		const linkedPageIds = Array.from(linkedPageIdsSet); // Convert Set back to an array

		// Check if the post was updated before LAST_BUILD_TIME
		const postLastUpdatedBeforeLastBuild =
			LAST_BUILD_TIME && post?.LastUpdatedTimeStamp && post.LastUpdatedTimeStamp < LAST_BUILD_TIME;

		// Check if any linked post was updated after LAST_BUILD_TIME
		const linkedPostsUpdated =
			!LAST_BUILD_TIME ||
			(linkedPageIds.length > 0 &&
				linkedPageIds.some((pageId) => {
					const linkedPost = allPostsMap[pageId];
					return linkedPost && linkedPost.LastUpdatedTimeStamp > LAST_BUILD_TIME;
				}));

		const shouldUseCache = postLastUpdatedBeforeLastBuild && !linkedPostsUpdated;

		return {
			params: { slug: post.Slug },
			props: { post, shouldUseCache, postLastUpdatedBeforeLastBuild },
		};
	});
}

interface Props {
	post: Post;
	shouldUseCache: boolean;
	postLastUpdatedBeforeLastBuild: boolean;
}

const { post, shouldUseCache, postLastUpdatedBeforeLastBuild } = Astro.props; // Extract shouldUseCache from props

resetCurrentHeadings();
let postFound = true;
let headings = null;
let blocks = null;
let referencesInPage = null;

if (!post) {
	console.log("Post not found. slug: ${slug}");
	postFound = false;
}

// Load cached HTML only if shouldUseCache is true
let cachedHtml = "";
if (postFound) {
	cachedHtml = await loadCachedHtml(post.Slug, shouldUseCache);
}

// Load cached headings if available
let cachedHeadings = null;
if (postFound) {
	cachedHeadings = await loadCachedHeadings(post.Slug, postLastUpdatedBeforeLastBuild);
}

let footnotesInPage = null;

if (postFound) {
	const result = await getPostContentByPostId(post);
	blocks = result.blocks;
	referencesInPage = result.referencesInPage;
	footnotesInPage = result.footnotesInPage;

	// Use cached headings if available, otherwise build and save them
	if (cachedHeadings) {
		headings = cachedHeadings;
	} else {
		headings = buildHeadings(blocks);
		await saveCachedHeadings(post.Slug, headings);
	}

	setCurrentHeadings(headings);

	// Process file blocks only if cache isn't used
	const fileAtacchedBlocks = extractTargetBlocks(
		["image", "video", "file", "audio"],
		blocks,
	).filter((block) => {
		if (!block) return false;
		const imageOrVideoOrAudioOrFile = block.NImage || block.File || block.Video || block.NAudio;
		return (
			imageOrVideoOrAudioOrFile &&
			imageOrVideoOrAudioOrFile.File &&
			imageOrVideoOrAudioOrFile.File.Url
		);
	});

	await processFileBlocks(fileAtacchedBlocks);
}
---

{
	postFound && resetFirstImage() && setTrackCurrentPageId(post.PageId) && (
		<PostLayout post={post} headings={headings} shouldUseCache={shouldUseCache} footnotesInPage={footnotesInPage}>
			<div class="post-body max-w-[708px] print:max-w-full" data-html-type={shouldUseCache && cachedHtml ? "cached" : "new"}>
				{shouldUseCache && cachedHtml ? (
					<div set:html={cachedHtml} />
				) : (
					<>
						<NotionBlocks blocks={blocks} />
						{/* Footnotes section - only render when NOT using cache (cached HTML already includes it) */}
						{adjustedFootnotesConfig?.['in-page-footnotes-settings']?.enabled &&
						 adjustedFootnotesConfig?.['in-page-footnotes-settings']?.['generate-footnotes-section'] &&
						 footnotesInPage && (
							<FootnotesSection footnotes={footnotesInPage} />
						)}
					</>
				)}
			</div>
		</PostLayout>
	)
}
