---
import NotionBlocks from "@/components/NotionBlocks.astro";
import PostLayout from "@/layouts/BlogPost.astro";
import {
	extractTargetBlocks,
	resetCurrentHeadings,
	resetFirstImage,
	setCurrentHeadings,
	setTrackCurrentPageId,
} from "@/lib/blog-helpers";
import { getAllPosts, getPostContentByPostId, processFileBlocks } from "@/lib/notion/client";
import type { Post } from "@/lib/interfaces";
import { buildHeadings } from "@/utils";
import { BUILD_FOLDER_PATHS, LAST_BUILD_TIME } from "@/constants";
import fs from "fs/promises";
import path from "path";
import superjson from "superjson";

export async function getStaticPaths() {
	const posts = await getAllPosts();

	return posts.map((post) => ({
		params: { slug: post.Slug },
		props: { post },
	}));
}

interface Props {
	post: Post;
}

const { post } = Astro.props;

resetCurrentHeadings();
let postFound = true;
let headings = null;
let blocks = null;
let referencesInPage = null;

if (!post) {
	console.log("Post not found. slug: ${slug}");
	postFound = false;
}

let postLastUpdatedBeforeLastBuild = false;
if (postFound) {
	postLastUpdatedBeforeLastBuild = LAST_BUILD_TIME
		? post?.LastUpdatedTimeStamp
			? post.LastUpdatedTimeStamp < LAST_BUILD_TIME
			: false
		: false;
}

let cachedHtml = "";
// If the page was updated before the last build, try to read the cached HTML.
if (postFound && postLastUpdatedBeforeLastBuild) {
	const cacheFilePath = path.join(BUILD_FOLDER_PATHS["blocksHtmlCache"], `${post.Slug}.html`);
	try {
		cachedHtml = await fs.readFile(cacheFilePath, "utf-8");
	} catch (e) {
		// File doesn't exist; fallback to rendering NotionBlocks.
		cachedHtml = "";
	}
}

let cachedHeadings = null;
const headingsCacheDir = BUILD_FOLDER_PATHS["headings"];
if (postFound && postLastUpdatedBeforeLastBuild) {
	const headingsCacheFile = path.join(headingsCacheDir, `${post.Slug}.json`);
	try {
		const headingsData = await fs.readFile(headingsCacheFile, "utf-8");
		cachedHeadings = superjson.parse(headingsData);
	} catch (e) {
		// Cache file doesn't exist.
		cachedHeadings = null;
	}
}

if (postFound) {
	const result = await getPostContentByPostId(post);
	blocks = result.blocks;
	referencesInPage = result.referencesInPage;

	// If we didn't load cached headings, build them from blocks.
	if (postLastUpdatedBeforeLastBuild && cachedHeadings) {
		headings = cachedHeadings;
	} else {
		headings = buildHeadings(blocks);
		setCurrentHeadings(headings);
		// Save the headings to cache for future builds.
		const headingsCacheFile = path.join(headingsCacheDir, `${post.Slug}.json`);
		try {
			await fs.writeFile(headingsCacheFile, superjson.stringify(headings), "utf-8");
		} catch (e) {
			console.error("Error saving headings cache:", e);
		}
	}

	if (!postLastUpdatedBeforeLastBuild) {
		const fileAtacchedBlocks = extractTargetBlocks(
			["image", "video", "file", "audio"],
			blocks,
		).filter((block) => {
			if (!block) return false;
			const imageOrVideoOrAudioOrFile = block.NImage || block.File || block.Video || block.NAudio;
			return (
				imageOrVideoOrAudioOrFile &&
				imageOrVideoOrAudioOrFile.File &&
				imageOrVideoOrAudioOrFile.File.Url
			);
		});

		await processFileBlocks(fileAtacchedBlocks);
	}
}
---

{
	postFound && resetFirstImage() && setTrackCurrentPageId(post.PageId) && (
		<PostLayout post={post} headings={headings}>
			{postLastUpdatedBeforeLastBuild && cachedHtml ? (
				<div
					class="post-body max-w-[708px] print:max-w-full"
					data-html-type="cached"
					set:html={cachedHtml}
				/>
			) : (
				<div class="post-body max-w-[708px] print:max-w-full" data-html-type="new">
					<NotionBlocks blocks={blocks} />
				</div>
			)}
		</PostLayout>
	)
}
