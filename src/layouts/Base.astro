---
import type { SiteMeta } from "@/types";
import BaseHead from "@/components/BaseHead.astro";
import Header from "@/components/layout/Header.astro";
import Footer from "@/components/layout/Footer.astro";
import SkipLink from "@/components/SkipLink.astro";
import { siteInfo } from "@/siteInfo";
import { ENABLE_LIGHTBOX, REFERENCES } from "@/constants";
import { adjustedFootnotesConfig } from "@/lib/notion/client";
interface Props {
meta: SiteMeta;
}
const {
meta: { title = siteInfo.title, description = siteInfo.description, ogImage, articleDate },
} = Astro.props;
---
<html lang={siteInfo.lang}>
   <head>
      <BaseHead title={title} description={description} ogImage={ogImage} articleDate={articleDate} />
   </head>
   <body class="print:max-w-full max-w-3xl">
      <SkipLink />
      <Header />
      <main id="main" class="lg:w-[125%]">
         <slot />
      </main>
      <Footer />
      <script type="module">
        // Listen for beforeprint event to open all details elements
window.addEventListener('beforeprint', function () {
    document.querySelectorAll('details').forEach(function (detail) {
        detail.setAttribute('open', true);
        detail.dataset.wasOpen = 'true'; // Mark it as opened by the script
    });
});

// Optional: Listen for afterprint event to close all details elements
// that were opened by the script
window.addEventListener('afterprint', function () {
    document.querySelectorAll('details').forEach(function (detail) {
        if (detail.dataset.wasOpen) {
            detail.removeAttribute('open');
            delete detail.dataset.wasOpen; // Clean up
        }
    });
});
      </script>
      {/*Lightbox */}
      {
      ENABLE_LIGHTBOX && (
      <script type="module">
         import 'https://cdn.jsdelivr.net/gh/mcstudios/glightbox/dist/js/glightbox.min.js';

         window.addEventListener('load', () => {
           const lightbox = GLightbox({
             selector: '.mediaglightbox, .fileglightbox, .embedglightbox'
           });
         });
      </script>
      )
      }
      {
      REFERENCES && REFERENCES["popovers"] && (

  <style>
    .popoverEl{
      left:0;
      top:0;
      max-width: calc(100vw - 10px);
    }
  </style>
      <script type="module">
    import {
      computePosition,
      offset,
      shift,
      flip,
      autoUpdate
  } from 'https://cdn.jsdelivr.net/npm/@floating-ui/dom@1.5.3/+esm';

  document.addEventListener('DOMContentLoaded', () => {
      // State variables for popovers
      let popoverTriggersSet = new Set(); // Track which elements have listeners

      // Determine if it's a mobile device
  let isSmBreakpoint = window.matchMedia('(max-width: 639px)').matches;
  let isLargeScreen = window.matchMedia('(min-width: 1024px)').matches;

// Create the selector based on the device type
// Exclude footnote markers with data-margin-note on large screens (they use margin notes instead)
function getPopoverSelector() {
  const isSmBreakpoint = window.matchMedia('(max-width: 639px)').matches;
  const isLargeScreen = window.matchMedia('(min-width: 1024px)').matches;

  return isSmBreakpoint
    ? '[data-popover-target]:not([data-popover-type-lm="true"])'
    : isLargeScreen
      ? '[data-popover-target]:not([data-margin-note])'
      : '[data-popover-target]';
}

// Select popover triggers based on the device-specific selector
const popoverTriggers = document.querySelectorAll(getPopoverSelector());

      let openPopovers = [];
      let cleanupAutoUpdate = new Map();
      let hoverTimeouts = new Map();

      const getPopoverLevel = (el) => {
          let level = 0;
          while (el && el.closest('[data-popover-target]')) {
              level++;
              el = el.parentElement;
          }
          // console.log(level - 1);
          return level - 1;
      };

      const hideAllPopovers = (level = 0) => {
          // console.log('hideAllPopovers called');
          // console.log(openPopovers);
          openPopovers.forEach(popoverEl => {
              if (getPopoverLevel(popoverEl) >= level) {
                  hidePopover(popoverEl);
              }
          });
      };

      const hidePopover = (popoverEl) => {
          // console.log('hidePopover called for', popoverEl);
          if (popoverEl) {
              popoverEl.style.visibility = 'hidden';
              popoverEl.classList.add('hidden');
              popoverEl.style.opacity = '0';
              popoverEl.style.top = '0px';
              popoverEl.style.left = '0px';

              const cleanup = cleanupAutoUpdate.get(popoverEl);
              if (cleanup) {
                  cleanup();
                  cleanupAutoUpdate.delete(popoverEl);
              }
              const openPopoverIndex = openPopovers.indexOf(popoverEl);
              if (openPopoverIndex !== -1) {
                  openPopovers.splice(openPopoverIndex, 1);
              }
          }
      };

      const addPTEventListeners = (triggerEl, popoverEl) =>
      {
        const isLinkMention = triggerEl.dataset.popoverTypeLm === "true";
        if (isLinkMention && isSmBreakpoint) {
    return;
  }
        if (triggerEl&& popoverEl){
        triggerEl.addEventListener('mouseleave', () => {
              const timeoutId = setTimeout(() => {
                  hidePopover(popoverEl);
              }, 100);
              hoverTimeouts.set(popoverEl, timeoutId);
          });

          triggerEl.addEventListener('blur-sm', () => {
              hidePopover(popoverEl);
          });

          popoverEl.addEventListener('mouseenter', () => {
              const timeoutId = hoverTimeouts.get(popoverEl);
              if (timeoutId) {
                  clearTimeout(timeoutId);
              }
          });

          popoverEl.addEventListener('mouseleave', () => {
              hidePopover(popoverEl);
          });
        }

          triggerEl.addEventListener('mouseenter', () => {
              const timeoutId = popoverEl? hoverTimeouts.get(popoverEl):null;
              if (timeoutId) {
                  clearTimeout(timeoutId);
                  hoverTimeouts.delete(popoverEl);
              }
              showPopover(triggerEl);
          });

          triggerEl.addEventListener('focus', () => {
              showPopover(triggerEl);
          });

    // Add click event listener for desktop link behavior (only for non-link-mentions)
    if (!isLinkMention) {
      triggerEl.addEventListener('click', (event) => {
        const href = triggerEl.dataset.href;
        if (href && !isSmBreakpoint) {  // Use !isSmBreakpoint instead of window.matchMedia
          event.preventDefault();
          window.location.href = href;
        } else {
          showPopover(triggerEl);
        }
      });
    }
      }

      const createPopover = (triggerEl) => {

          const popoverID = triggerEl.dataset.popoverTarget;
          const template = document.getElementById(`template-${popoverID}`);
          if (!template) return null;
          const popoverEl = template.content.firstElementChild.cloneNode(true);
          triggerEl.parentNode.insertBefore(popoverEl, triggerEl.nextSibling);
          addPTEventListeners(triggerEl, popoverEl);
          // Add event listeners to any new popover triggers within this popover
          const nestedSelector = isSmBreakpoint
    ? '[data-popover-target]:not([data-popover-type-lm="true"])'
    : isLargeScreen
      ? '[data-popover-target]:not([data-margin-note])'
      : '[data-popover-target]';
    const nestedTriggers = popoverEl.querySelectorAll(nestedSelector);
    nestedTriggers.forEach(nestedTrigger => {
      addPTEventListeners(nestedTrigger, null);
    });
          return popoverEl;

      };

      const showPopover = (triggerEl) => {
          const level = getPopoverLevel(triggerEl);
          hideAllPopovers(level);
          let popoverEl = document.getElementById(triggerEl.dataset.popoverTarget);

          if (!popoverEl) {
              popoverEl = createPopover(triggerEl);
          }
          if (!popoverEl) return;

          const update = () => {
              computePosition(triggerEl, popoverEl, {
                  middleware: [offset(6), shift({
                      padding: 3
                  }), flip({
                      padding: 3
                  })]
              }).then(({
                  x,
                  y
              }) => {
                  Object.assign(popoverEl.style, {
                      left: `${x}px`,
                      top: `${y}px`,
                      position: 'absolute'
                  });
              });
          };

          update();
          popoverEl.classList.remove('hidden');
          requestAnimationFrame(() => {
              popoverEl.style.visibility = 'visible';
              popoverEl.style.opacity = '1';
          });

          openPopovers.push(popoverEl);
          cleanupAutoUpdate.set(popoverEl, autoUpdate(triggerEl, popoverEl, update));
      };

      // Function to initialize popover triggers for footnote markers only (on resize to small screen)
      const initializeFootnotePopoverTriggers = () => {
          // Only add listeners to footnote markers that don't already have them
          const footnoteMarkers = document.querySelectorAll('[data-margin-note]');

          footnoteMarkers.forEach(triggerEl => {
              // Only add listeners if not already added
              if (!popoverTriggersSet.has(triggerEl)) {
                  addPTEventListeners(triggerEl, null);
                  popoverTriggersSet.add(triggerEl);
              }
          });
      };

      // Initialize popovers for the first time
      popoverTriggers.forEach(triggerEl => {
          addPTEventListeners(triggerEl, null);
          popoverTriggersSet.add(triggerEl);
      });

      // Store the initialization function globally so resize handler can access it
      window.reinitializeFootnotePopovers = initializeFootnotePopoverTriggers;

      document.addEventListener('click', (event) => {
          const popoverLink = event.target.closest('[data-popover-link]');
          if (popoverLink) {
              hideAllPopovers(-1);
          } else if (!event.target.closest('[data-popover-target]')) {
              hideAllPopovers(-1);
          }
      });

      document.addEventListener('keydown', (event) => {
          if (event.key === 'Escape') {
              hideAllPopovers(-1);
          }
      });
  });
</script>



      )
      }
{/* Margin Notes Script (for small-popup-large-margin display mode) */}
{adjustedFootnotesConfig && adjustedFootnotesConfig["in-page-footnotes-settings"]?.["intext-display"]?.["small-popup-large-margin"] && (
<script type="module">
  /**
   * Initializes Tufte-style margin notes for footnotes
   *
   * LAYOUT STRATEGY:
   * - Main already expands to 125% on large screens via lg:w-[125%]
   * - This creates ~172px of space to the right of .post-body (708px)
   * - Footnotes positioned absolutely relative to .post-body, overflowing into this space
   * - No need to modify article/body widths - space already exists!
   *
   * BEHAVIOR:
   * - Desktop (≥1024px): Always visible margin notes (Tufte style)
   * - Mobile (<1024px): Falls back to Base.astro popover system
   * - Hover marker or note: Highlights both
   * - Overlapping notes: Automatically stacked with gaps
   */
  document.addEventListener('DOMContentLoaded', () => {
    // Initialize margin notes if on large screen
    if (window.matchMedia('(min-width: 1024px)').matches) {
      positionMarginNotes();
    }

    // Handle window resize
    let resizeTimeout;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        const isLargeScreen = window.matchMedia('(min-width: 1024px)').matches;

        if (isLargeScreen) {
          // Switched to large screen - remove margin notes and recreate them
          document.querySelectorAll('.footnote-margin-note').forEach(n => n.remove());
          positionMarginNotes();

          // Hide any open popovers for footnote markers and mark them as non-interactive
          document.querySelectorAll('[data-margin-note]').forEach(marker => {
            const popoverId = marker.getAttribute('data-popover-target');
            if (popoverId) {
              const popover = document.getElementById(popoverId);
              if (popover) {
                popover.style.display = 'none';
                popover.style.visibility = 'hidden';
                popover.classList.add('hidden');
              }
            }
          });
        } else {
          // Switched to small screen - remove margin notes and reinitialize popover listeners for footnotes only
          document.querySelectorAll('.footnote-margin-note').forEach(n => n.remove());

          // Re-enable popovers for footnote markers
          document.querySelectorAll('[data-margin-note]').forEach(marker => {
            const popoverId = marker.getAttribute('data-popover-target');
            if (popoverId) {
              const popover = document.getElementById(popoverId);
              if (popover) {
                popover.style.display = '';
              }
            }
          });

          // Reinitialize popover listeners only for footnote markers that were previously excluded
          if (window.reinitializeFootnotePopovers) {
            window.reinitializeFootnotePopovers();
          }
        }
      }, 250);
    });
  });

  function positionMarginNotes() {
    const markers = document.querySelectorAll('[data-margin-note]');

    markers.forEach((markerEl) => {
      const footnoteId = markerEl.getAttribute('data-margin-note');
      if (!footnoteId) return;

      const template = document.getElementById(`template-margin-${footnoteId}`);
      if (!template) return;

      const postBody = markerEl.closest('.post-body');
      if (!postBody) return;

      // Skip if inside a post-preview-full-container (collection full preview pages)
      if (postBody.classList.contains('post-preview-full-container')) return;

      if (getComputedStyle(postBody).position === 'static') {
        postBody.style.position = 'relative';
      }

      const marginNote = document.createElement('aside');
      marginNote.className = 'footnote-margin-note absolute left-full ml-8 w-32 xl:ml-12 xl:w-48 text-sm leading-relaxed text-gray-500 dark:text-gray-400 opacity-70 transition-opacity duration-200 pointer-events-auto';
      marginNote.dataset.noteId = footnoteId;

      const content = template.content.cloneNode(true);
      marginNote.appendChild(content);

      const postBodyRect = postBody.getBoundingClientRect();
      const markerRect = markerEl.getBoundingClientRect();
      const topOffset = markerRect.top - postBodyRect.top + postBody.scrollTop;

      marginNote.style.top = `${topOffset}px`;

      postBody.appendChild(marginNote);

      setupHoverHighlight(markerEl, marginNote);
    });

    // After all notes are created, stack them globally to prevent overlaps
    stackAllMarginNotesGlobally();
  }

  function setupHoverHighlight(marker, note) {
    marker.addEventListener('mouseenter', () => {
      marker.classList.add('highlighted');
      note.classList.add('highlighted');
    });

    marker.addEventListener('mouseleave', () => {
      marker.classList.remove('highlighted');
      note.classList.remove('highlighted');
    });

    note.addEventListener('mouseenter', () => {
      marker.classList.add('highlighted');
      note.classList.add('highlighted');
    });

    note.addEventListener('mouseleave', () => {
      marker.classList.remove('highlighted');
      note.classList.remove('highlighted');
    });
  }


  /**
   * Stacks all margin notes globally to prevent overlaps across different blocks
   * This ensures that even if Block 1 has a very long footnote, it won't overlap
   * with footnotes from Block 2
   */
  function stackAllMarginNotesGlobally() {
    // Find all margin notes in the document
    const allNotes = Array.from(document.querySelectorAll('.footnote-margin-note'));

    if (allNotes.length === 0) return;

    // Sort by initial top position
    allNotes.sort((a, b) => {
      const aTop = parseInt(a.style.top) || 0;
      const bTop = parseInt(b.style.top) || 0;
      return aTop - bTop;
    });

    // Stack with minimum gap of 8px
    for (let i = 1; i < allNotes.length; i++) {
      const prevNote = allNotes[i - 1];
      const currNote = allNotes[i];

      const prevTop = parseInt(prevNote.style.top) || 0;
      const prevBottom = prevTop + prevNote.offsetHeight;
      const currTop = parseInt(currNote.style.top) || 0;

      // If current note would overlap with previous note, push it down
      if (currTop < prevBottom + 8) {
        currNote.style.top = `${prevBottom + 8}px`;
      }
    }
  }
</script>

<style>
  /* ===================================================================
     Margin Notes (Tufte-style, desktop only)
     =================================================================== */

  /**
   * LAYOUT STRATEGY:
   * - .post-body is the positioning context (position: relative set by JS)
   * - Main already expands to 125% (960px) via lg:w-[125%]
   * - Content is 708px wide, leaving ~172px to the right
   * - Notes positioned absolutely: left: 100% overflows into this space
   * - No need to modify article/body widths!
   */

  /* Highlighted state for margin notes (toggled via JavaScript) */
  .footnote-margin-note.highlighted {
    opacity: 1;
    color: rgb(31 41 55); /* gray-800 */
  }

  :global(.dark) .footnote-margin-note.highlighted {
    color: rgb(243 244 246); /* gray-100 */
  }

  /* Make second child (first content block after <sup>) in blocks-type margin notes display inline with the marker */
  .footnote-margin-blocks > :nth-child(2) {
    display: inline !important;
    margin-top: 0 !important;
  }

  @media (max-width: 1023px) {
    .footnote-margin-note {
      display: none;
    }
  }

  @media (min-width: 1024px) {
    .footnote-margin-note {
      display: block;
    }

    .post-body {
      position: relative;
    }
  }

  /* Hide margin notes when inside PostPreviewFull component (collection full preview pages) */
  .post-preview-full-container .footnote-margin-note {
    display: none !important;
  }

  .footnote-marker span.highlighted {
    background-color: rgb(254 249 195); /* yellow-100 */
  }

  :global(.dark) .footnote-marker span.highlighted {
    background-color: rgb(113 63 18); /* yellow-900 */
  }
</style>
)}

<script>
  document.addEventListener('DOMContentLoaded', function() {
    const dataTables = document.querySelectorAll('table.datatable');
    if (dataTables.length > 0) {
      // Load simple-datatables script
      const script = document.createElement('script');
      script.src = 'https://cdn.jsdelivr.net/npm/simple-datatables@latest';
      script.onload = initDataTables;
      document.head.appendChild(script);

      // Load simple-datatables CSS
      const link = document.createElement('link');
      link.rel = 'stylesheet';
      link.href = 'https://cdn.jsdelivr.net/npm/simple-datatables@latest/dist/style.min.css';
      document.head.appendChild(link);

      // Add custom styles
      const style = document.createElement('style');
      style.textContent = `
        .datatable-input {
          padding: 3px 6px;
          border: 1px solid #ccc;
          border-radius: 6px;
          font-size: 14px;
          transition: all 0.3s ease;
          width: 100%;
          box-sizing: border-box;
        }
        .datatable-input:focus {
          border-color: #007bff;
          outline: none;
          box-shadow: 0 0 0 0.2rem rgba(0,123,255,.25);
        }
        .filter-toggle {
          background: none;
          border: none;
          font-size: 20px;
          cursor: pointer;
          padding: 0 10px;
          transition: all 0.3s ease;
        }
        .filter-toggle:hover {
          opacity: 0.7;
        }
        .filter-row, .search-inputs {
          transition: all 0.3s ease;
          max-height: 50px;
          opacity: 1;
          overflow: hidden;
        }
        .filter-row.hide, .search-inputs.hide {
          max-height: 0;
          display:none;
          opacity: 0;
          padding-top: 0;
          padding-bottom: 0;
          margin-top: 0;
          margin-bottom: 0;
        }
        .datatable-top {
          display: flex;
          flex-wrap: wrap;
          justify-content: space-between;
          align-items: center;
          padding: 4px;
          margin-bottom: 10px;
        }
        .datatable-top-left {
          display: flex;
          align-items: center;
          flex-grow: 1;
        }
        .datatable-info {
          font-size: small;
          font-family: monospace;
          transition: all 0.3s ease;
          white-space: nowrap;
        }
        .datatable-sorter {
          background-color: transparent !important;
          position: relative;
          padding-right: 1rem; /* Reserve enough space for the sort icons */
        }
        .datatable-sorter::after {
          border-bottom-color:var(--color-accent) !important;
          top: -2px !important;
        }

        .datatable-sorter::before {
          border-top-color:var(--color-accent) !important;
        }

        .datatable-table>tbody>tr>td, .datatable-table>tbody>tr>th, .datatable-table>tfoot>tr>td, .datatable-table>tfoot>tr>th, .datatable-table>thead>tr>td, .datatable-table>thead>tr>th {
          padding: calc(var(--spacing) * 2);
        }

        html.dark :not(.datatable-ascending):not(.datatable-descending) > .datatable-sorter::after,
        html.dark :not(.datatable-ascending):not(.datatable-descending) > .datatable-sorter::before {
          opacity: 0.3 !important;
        }

        .datatable-wrapper .datatable-container {
          border: none !important;
        }

        .datatable-table>thead>tr>th {
          border-bottom-color: rgba(229, 231, 235, 0.9);
        }

        .dark .datatable-table>thead>tr>th {
          border-bottom-color: rgba(55, 65, 81, 0.9);
        }

        @media (max-width: 640px) {
          .datatable-top {
            flex-wrap: nowrap;
          }
          .datatable-top-left {
            width: auto;
            margin-bottom: 0;
          }
          .datatable-info {
            padding-left: 8px;
          }
          .datatable-top.filter-active {
            flex-direction: column;
            align-items: stretch;
          }
          .datatable-top.filter-active .datatable-top-left {
            width: 100%;
            margin-bottom: 8px;
          }
          .datatable-top.filter-active .datatable-info {
            width: 100%;
            padding-right: 8px;
            text-align: right;
          }
        }
      `;
      document.head.appendChild(style);
    }
  });

  function initDataTables() {
    const dataTables = document.querySelectorAll('table.datatable');
    let options = {
      searchable: true,
      paging: false,
      labels: {"info": "{rows} rows"},
      tableRender: (_data, table, type) => {
        if (type === "print") {
          return table;
        }
        const tHead = table.childNodes[0];
        const filterHeaders = {
          nodeName: "TR",
          attributes: {
            class: "filter-row hide",
          },
          childNodes: tHead.childNodes[0].childNodes.map(
            (_th, index) => ({
              nodeName: "TH",
              childNodes: [
                {
                  nodeName: "INPUT",
                  attributes: {
                    class: "datatable-input",
                    type: "search",
                    "data-columns": `[${index}]`,
                    "aria-label": `Filter column ${index + 1}`,
                  }
                }
              ]
            })
          )
        };
        tHead.childNodes.push(filterHeaders);
        return table;
      },
      template: (options, dom) => `
        <div class='${options.classes.top}'>
          <div class="datatable-top-left">
            <button class="filter-toggle cursor-pointer" style="padding: 8px;" aria-label="Toggle filters and search">
              <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 30 30">
                <path fill="currentColor" d="M19.3 17.89c1.32-2.1.7-4.89-1.41-6.21a4.52 4.52 0 0 0-6.21 1.41C10.36 15.2 11 18 13.09 19.3c1.47.92 3.33.92 4.8 0L21 22.39L22.39 21zm-2-.62c-.98.98-2.56.97-3.54 0c-.97-.98-.97-2.56.01-3.54c.97-.97 2.55-.97 3.53 0c.96.99.95 2.57-.03 3.54zM19 4H5a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h5.81a6.3 6.3 0 0 1-1.31-2H5v-4h4.18c.16-.71.43-1.39.82-2H5V8h6v2.81a6.3 6.3 0 0 1 2-1.31V8h6v2a6.5 6.5 0 0 1 2 2V6a2 2 0 0 0-2-2"/>
              </svg>
            </button>
            <div class='${options.classes.search} search-inputs hide' style="display: flex; gap: 10px;">
              <input class='${options.classes.input}' placeholder='OR search' type='search' aria-label='OR search' title='${options.labels.searchTitle}'${dom.id ? ` aria-controls="${dom.id}"` : ""}>
              <input class='${options.classes.input}' placeholder='AND search' type='search' aria-label='AND search' data-and="true" title='${options.labels.searchTitle}'${dom.id ? ` aria-controls="${dom.id}"` : ""}>
            </div>
          </div>
          <div class='${options.classes.info}'></div>
        </div>
        <div class='${options.classes.container}'${options.scrollY.length ? ` style='height: ${options.scrollY}; overflow-Y: auto;'` : ""}></div>
      `
    };

    dataTables.forEach(table => {
      const dt = new simpleDatatables.DataTable(table, options);

      // Custom search function
      const customSearch = (query, row, andSearch) => {
        const searchTerms = query.toLowerCase().split(' ');
        const rowData = row.toLowerCase();

        if (andSearch) {
          return searchTerms.every(term => rowData.includes(term));
        } else {
          return searchTerms.some(term => rowData.includes(term));
        }
      };

      // Override the default search behavior
      dt.on('datatable.search', function(query, matched) {
        const andSearchInput = this.wrapperDOM.querySelector('input[data-and="true"]');
        const andSearchQuery = andSearchInput ? andSearchInput.value : '';
        const columnFilters = Array.from(this.wrapperDOM.querySelectorAll('.datatable-input')).map(input => input.value);

        this.data.forEach((row, index) => {
          const tr = this.activeRows[index];
          const orMatch = customSearch(query, row.join(' '), false);
          const andMatch = customSearch(andSearchQuery, row.join(' '), true);
          const columnMatch = columnFilters.every((filter, i) =>
            filter === '' || customSearch(filter, row[i], false)
          );

          if (orMatch && andMatch && columnMatch) {
            tr.style.display = '';
          } else {
            tr.style.display = 'none';
          }
        });

        this.update();
        this.emit('datatable.afterSearch', query, matched);
      });

      // Add event listener for AND search
      const andSearchInput = dt.wrapperDOM.querySelector('input[data-and="true"]');
      andSearchInput.addEventListener('keyup', function() {
        dt.search(dt.input.value);
      });

      // Add event listeners for column filters
      const columnFilters = dt.wrapperDOM.querySelectorAll('.datatable-input');
      columnFilters.forEach(input => {
        input.addEventListener('keyup', function() {
          dt.search(dt.input.value);
        });
      });

      // Add event listener for filter toggle button
      const filterToggle = dt.wrapperDOM.querySelector('.filter-toggle');
      const filterRow = dt.wrapperDOM.querySelector('.filter-row');
      const searchInputs = dt.wrapperDOM.querySelector('.search-inputs');
      const datatableTop = dt.wrapperDOM.querySelector('.datatable-top');
      filterToggle.addEventListener('click', function() {
        const columnFilters = dt.wrapperDOM.querySelectorAll('.datatable-input');
        const areAllEmpty = Array.from(columnFilters).every(input => input.value === '');
        const isHidden = filterRow.classList.contains('hide');

        if (isHidden || !areAllEmpty) {
          filterRow.classList.remove('hide');
          searchInputs.classList.remove('hide');
          datatableTop.classList.add('filter-active');
          filterToggle.setAttribute('aria-expanded', 'true');
        } else {
          filterRow.classList.add('hide');
          searchInputs.classList.add('hide');
          datatableTop.classList.remove('filter-active');
          filterToggle.setAttribute('aria-expanded', 'false');
        }
      });

      // Set initial aria-expanded state
      filterToggle.setAttribute('aria-expanded', 'false');
    });
  }
</script>

   </body>
</html>
